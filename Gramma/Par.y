-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.3).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Gramma.Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Gramma.Abs
import Gramma.Lex
import qualified Data.Text

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  ','           { PT _ (TS _ 1)          }
  ':'           { PT _ (TS _ 2)          }
  ';'           { PT _ (TS _ 3)          }
  'ASSIGN'      { PT _ (TS _ 4)          }
  'BEGIN'       { PT _ (TS _ 5)          }
  'DIV'         { PT _ (TS _ 6)          }
  'DO'          { PT _ (TS _ 7)          }
  'DOWNTO'      { PT _ (TS _ 8)          }
  'ELSE'        { PT _ (TS _ 9)          }
  'END'         { PT _ (TS _ 10)         }
  'ENDFOR'      { PT _ (TS _ 11)         }
  'ENDIF'       { PT _ (TS _ 12)         }
  'ENDWHILE'    { PT _ (TS _ 13)         }
  'EQ'          { PT _ (TS _ 14)         }
  'FOR'         { PT _ (TS _ 15)         }
  'FROM'        { PT _ (TS _ 16)         }
  'GE'          { PT _ (TS _ 17)         }
  'GEQ'         { PT _ (TS _ 18)         }
  'IF'          { PT _ (TS _ 19)         }
  'LE'          { PT _ (TS _ 20)         }
  'LEQ'         { PT _ (TS _ 21)         }
  'MINUS'       { PT _ (TS _ 22)         }
  'MOD'         { PT _ (TS _ 23)         }
  'NEQ'         { PT _ (TS _ 24)         }
  'PLUS'        { PT _ (TS _ 25)         }
  'READ'        { PT _ (TS _ 26)         }
  'REPEAT'      { PT _ (TS _ 27)         }
  'THEN'        { PT _ (TS _ 28)         }
  'TIMES'       { PT _ (TS _ 29)         }
  'TO'          { PT _ (TS _ 30)         }
  'UNTIL'       { PT _ (TS _ 31)         }
  'VAR'         { PT _ (TS _ 32)         }
  'WHILE'       { PT _ (TS _ 33)         }
  'WRITE'       { PT _ (TS _ 34)         }
  '['           { PT _ (TS _ 35)         }
  ']'           { PT _ (TS _ 36)         }
  L_Pidentifier { PT _ (T_Pidentifier _) }
  L_Number      { PT _ (T_Number $$)     }

%%

Pidentifier :: { Gramma.Abs.Pidentifier }
Pidentifier  : L_Pidentifier { Gramma.Abs.Pidentifier (mkPosToken $1) }

Number :: { Gramma.Abs.Number }
Number  : L_Number { Gramma.Abs.Number $1 }

Program :: { Gramma.Abs.Program }
Program
  : 'VAR' ListDeclaration 'BEGIN' ListCommand 'END' { Gramma.Abs.Program $2 $4 }
  | 'BEGIN' ListCommand 'END' { Gramma.Abs.simpleProg $2 }

ListDeclaration :: { [Gramma.Abs.Declaration] }
ListDeclaration
  : Declaration { (:[]) $1 }
  | Declaration ',' ListDeclaration { (:) $1 $3 }

Declaration :: { Gramma.Abs.Declaration }
Declaration
  : Pidentifier { Gramma.Abs.ScalarDecl $1 }
  | Pidentifier '[' Number ':' Number ']' { Gramma.Abs.ArrayDecl $1 $3 $5 }

ListCommand :: { [Gramma.Abs.Command] }
ListCommand
  : Command { (:[]) $1 } | Command ListCommand { (:) $1 $2 }

Command :: { Gramma.Abs.Command }
Command
  : Identifier 'ASSIGN' Expression ';' { Gramma.Abs.Assign $1 $3 }
  | 'IF' Condition 'THEN' ListCommand 'ELSE' ListCommand 'ENDIF' { Gramma.Abs.IfElse $2 $4 $6 }
  | 'IF' Condition 'THEN' ListCommand 'ENDIF' { Gramma.Abs.ifElseSkip $2 $4 }
  | 'WHILE' Condition 'DO' ListCommand 'ENDWHILE' { Gramma.Abs.While $2 $4 }
  | 'REPEAT' ListCommand 'UNTIL' Condition ';' { Gramma.Abs.Repeat $2 $4 }
  | 'FOR' Pidentifier 'FROM' Value 'TO' Value 'DO' ListCommand 'ENDFOR' { Gramma.Abs.ForTo $2 $4 $6 $8 }
  | 'FOR' Pidentifier 'FROM' Value 'DOWNTO' Value 'DO' ListCommand 'ENDFOR' { Gramma.Abs.ForDownTo $2 $4 $6 $8 }
  | 'READ' Identifier ';' { Gramma.Abs.Read $2 }
  | 'WRITE' Value ';' { Gramma.Abs.Write $2 }

Expression :: { Gramma.Abs.Expression }
Expression
  : Value { Gramma.Abs.ValueExpr $1 }
  | Value 'PLUS' Value { Gramma.Abs.Plus $1 $3 }
  | Value 'MINUS' Value { Gramma.Abs.Minus $1 $3 }
  | Value 'TIMES' Value { Gramma.Abs.Times $1 $3 }
  | Value 'DIV' Value { Gramma.Abs.Div $1 $3 }
  | Value 'MOD' Value { Gramma.Abs.Mod $1 $3 }

Condition :: { Gramma.Abs.Condition }
Condition
  : Value 'EQ' Value { Gramma.Abs.Eq $1 $3 }
  | Value 'NEQ' Value { Gramma.Abs.Neq $1 $3 }
  | Value 'LE' Value { Gramma.Abs.Le $1 $3 }
  | Value 'GE' Value { Gramma.Abs.Ge $1 $3 }
  | Value 'LEQ' Value { Gramma.Abs.Leq $1 $3 }
  | Value 'GEQ' Value { Gramma.Abs.Geq $1 $3 }

Value :: { Gramma.Abs.Value }
Value
  : Number { Gramma.Abs.NumValue $1 }
  | Identifier { Gramma.Abs.IdValue $1 }

Identifier :: { Gramma.Abs.Identifier }
Identifier
  : Pidentifier { Gramma.Abs.ScalarId $1 }
  | Pidentifier '[' Pidentifier ']' { Gramma.Abs.VarArrayId $1 $3 }
  | Pidentifier '[' Number ']' { Gramma.Abs.ConstArrayId $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

}

